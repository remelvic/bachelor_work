# TIMEWORK 4 hours 6.10.22


# The Twelve Factor App

Twe 12factor App — это методология для создания SaaS-приложений, которые:

(Минимум времени интеграции в проект новых разработчиков, соглашения с операционными системами, развертывание на облачных платформах, минимальное расхождение между разработкой и продакшеном, масштабирование без существенных изменений в разработке и инструментах)

 - Используют __декларативный__ формат для описания процесса установки и настройки, что сводит к минимуму затраты времени и ресурсов для новых разработчиков, подключённых к проекту;
 - Имеют __соглашение__ с операционной системой, предполагающее __максимальную переносимость__ между средами выполнения;
 - Подходят для __развёртывания__ на современных __облачных платформах__, устраняя необходимость в серверах и системном администрировании;
 - __Сводят к минимуму расхождения__ между средой разработки и средой выполнения, что позволяет использовать __непрерывное развёртывание__ (continuous deployment) для максимальной гибкости;
 - И могут __масштабироваться__ без существенных изменений в инструментах, архитектуре и практике разработки.

 ## 12 ФАКТРОВ
 --- 
 1) __Кодовая база__ Одна кодовая база, отслеживаемая в системе контроля версей - множество развертываний

     Приложение не может использовать тот же самой код что и другое приложение. Это нарушает 12 факторов. _ВЫХОД :_ выделение общего кода в библиотеки, которые потом можно подключить через [менеджер зависимостей](#Зависимости).

---

 2) __Зависимости__ Явно объявляйте и изолируйте зависимости 

    Приложение 12 факторов никогда __не зависит__ от неявно существующих, доступных по всей системе пакетов.
---

 3) __Конфигурация__ Сохраняйте конфигурацию в среде выполнения

    Иногда приложения хранят конфигурации как константы в коде. Это нарушение методологии двенадцати факторов, которая требует __строгого разделения конфигурации и кода__. Конфигурация может существенно различаться между развёртываниями, код не должен различаться.

    Лакмусовой бумажкой того, правильно ли разделены конфигурация и код приложения, является факт того, что кодовая база приложения может быть в любой момент открыта в свободный доступ без компрометации каких-либо приватных данных.

    __Приложение двенадцати факторов хранит конфигурацию в переменных окружения__ (часто сокращается до __env vars__ или __env__).  Переменные окружения легко изменить между развёртываниями, не изменяя код

 ---
 4) __Сторонние службы (Backing Services)__ Считайте стороние службы подключаемыми ресурсами

    __Код приложения двенадцати факторов не делает различий между локальными и сторонними сервисами.__ Подключение и отключение баз данных, апичек и т.д. без каких-либо изменений кода. 
 ---
 5) __Сборка, релиз, выполнение__ Строго разделяйте стадии сборки и выполнения

    _Этап сборки_ - преобразует репозиторий кода в исполняемый пакет, называемый _сборка_.
    _Этап релиза_ принимает сборку и объединяет её с текущей конфигурацией развёртывания. Релиз готов к запуска в среде выполнения
    _Этап выполнения_ запускает приложение в среде выполнения путём запуска некоторого набора процессов приложения из определённого релиза.

 ---
 6) __Процессы__ Запускайте приложение как один или несколько процессов не сохраняющих внутреннее состояние

    __Процессы приложения двенадцати факторов не сохраняют внутреннее состояние (stateless) и не имеют разделяемых данных (share-nothing)__

 ---
 7) __Привязка портов__ Экспортируйте сервисы через привязку портов

    Веб-приложение __экспортирует HTTP-сервис путём привязки к порту__ и прослушивает запросы, поступающих на этот порт.

 ---
 8) __Параллелизм__ Масштабируйте приложение с помощью процессов

    Процессы в приложении двенадцати факторов взяли сильные стороны из модели процессов Unix для запуска демонов. С помощью этой модели разработчик может спроектировать своё приложение таким образом, что для обработки различной рабочей нагрузки необходимо назначить каждому типу работы свой типа процесса.

 ---
 9) __Утилизируемость (Disposability)__ Максимизируйте надежность с помощью быстрого запуска и корректного завершения работы 

    __Приложения 12 факторов могут быть запущены и остановлены в любой момент.__ Процессы должны стараться __минимизировать время запуска__.
    
    Процессы должны __завершаться корректно, когда они получают SIGTERM__ сигнал от диспетчера процессов.

    Процессы также должны быть __устойчивыми к внезапной смерти__ в случае отказа аппаратного обеспечения. Хотя это мало вероятно, но это может случиться. И по закону подлости (_Murphy's law_) это случиться в самый неподходящий момент.

 ---

 10) __Паритет разработки/работы приложения__ 
 Держите окружение разработки,промежуточного развертывания и рабочего развертывания максимально похожими

 Различия между разработкой и работой приложения:
    
- __Различие во времени__: разработчик может работать с кодом, который попадёт в рабочую версию приложения только через дни, недели или даже месяцы.
    
- __Различие персонала__: разработчики пишут код, OPS инженеры разворачивают его.
    
- __Различие инструментов__: разработчики могут использовать стек технологий, такой как Nginx, SQLite, и OS X, в то время как при рабочем развёртывании используются Apache, MySQL и Linux.

 ---
 11) __Журналирование__ Рассматривайте журнал как поток событий

 __Приложение двенадцати факторов никогда не занимается маршрутизацией и хранением своего потока вывода__. Приложение не должно записывать журнал в файл и управлять файлами журналов. Вместо этого каждый выполняющийся процесс записывает свой поток событий без буферизации в стандартный вывод ```stdout```. Во время локальной разработки разработчик имеет возможность просматривать этот поток в терминале, чтобы наблюдать за поведением приложения

 ---
 12) __Задачи администрирования__ Выполняйте задачи администрирования/управления с помощью разовых процессов

  Разовые процессы администрирования следует запускать в среде идентичной регулярным длительным процессам приложения. Они запускаются на уровне релиза, используя те же кодовую базу и конфигурацию, как и любой другой процесс, выполняющий этот релиз. Код администрирования должен поставляться вместе с кодом приложения, чтобы избежать проблем синхронизации.

# Distributed Tracing (Распределенная Трассировка)

__Распределенная трассировка__ это метод используемый для профилирования и мониторинга приложений, особенно микросервисных. Распределенная трассировка помогает определить где происходят сбои и что вызывает низкую производительность https://opentracing.io/docs/overview/what-is-tracing/

Open Tracing __НЕ__ является загрузкой или программой. __НЕ__ является стандартом. Ее требуется добавлять в инструментарий разработчка,используя API, или в фреймворки.

Open Tracing состоит из спецификации API, фреймворков и библиотек. 



# OpenTelemetry 

__OpenTelemetry__ это набор инструментов API и SDK. Используется для обработки, генерации, сбора и экспорта данных (metrics, logs,traces), чтоб проанализировать производительность и поведение ПО.

## What is Observability? 
 Наблюдаемость позволяет нам понять систему извне, задавая вопросы об этой системе, не зная ее внутренней работы. Помогает легко устронять неполадки и решать новые проблемы и понять почему именно что-либо происходит.

 __Metrics__ - частота системных ошибок, загрузка процессора, частота запросов для данной службы.

 __SLI (Service Level Indicator)__ - оценивает наш сервис с точки зрения пользователя. Например как быстро загрузилась веб-страница
 __SLO (Service Level Objective)__ - средство, с помощью которого надеждность доводится до сведения организации.


## Metrics
Сегодня OpenTelemetry определяет три метрических инструмента:

__counter__ - он только увеличивается 

__measure__ - представляет значение в некотором определенном диапазоне 

__observer__ - фиксирует текущий набор значений (Напр. указатель уровня топлива в автомобиле)

В отличии от трассировки запросов, которые отслеживают жизненные циклы запросов и предоставляют контекст для отдельных частей запроса, метрики предоставляют статическую информацию в совокупности. 

## Baggage 

__Багаж относиться к контекстной ифне, которая передается между spans__

Багаж используется для хранения конфиденциальных данных, которые вы можете предоставить третьим лицами

Baggae != Span attributes

## Collector 

__Collector__ получает, обрабатывает и экспортирует данные телеметрии. Поддерживает прием данных в формате (OLTP, Jaeger, Prometheus а множество коммерческих инструментов) и отправку данных на один или несколько серверов. 

